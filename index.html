<!--
	the flipfluid simulation part is hugely insipired by:
	Copyright 2022 Matthias Müller - Ten Minute Physics, 
	www.youtube.com/c/TenMinutePhysics
	www.matthiasMueller.info/tenMinutePhysics
-->

<!DOCTYPE html>
<html>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<head>
		<title>SEAL_ISU_concept</title>
		<link rel="stylesheet" href="seal_isu_style.css">
	</head>
<body onscroll="changeBackgroundColor()">
	<!-- <script src="script.js"></script> -->
	<script>
        function changeBackgroundColor() {
            var scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            var scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
            // var scrollPercentage = scrollTop / scrollHeight;
			var scrollPercentage = scrollTop / window.innerHeight * 2/3;
            // var colorValue = Math.round(255 * (1 - scrollPercentage));
			let colorValue;

			if (scrollPercentage <= 2 / 3) {
				let progress = scrollPercentage / (2 / 3);
				colorValue = Math.round(255 * (1 - progress));
			} else {
				let progress = (scrollPercentage - 2 / 3) / (2 / 3);
				colorValue = Math.round(255 * progress);
			}
			document.body.style.backgroundColor = 'rgb(' + colorValue + ',' + colorValue + ',' + colorValue + ')';
        }
		function scrollToHalfPage() {
            // Scrolls to the 100vh mark
            window.scrollTo({
                top: window.innerHeight, // 100vh equivalent
                behavior: 'smooth' // Smooth scroll
            });
        }
		// function changeInvertColor() {
        //     var scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        //     var scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
        //     // var scrollPercentage = scrollTop / scrollHeight;
		// 	var scrollPercentage = scrollTop / window.innerHeight;
        //     var invertPercentage = Math.max(0, scrollPercentage * 0);
        //     video.style.filter = `invert(${invertPercentage}%)`;
        // }
		window.addEventListener('scroll', function() {
			var video = document.getElementById('myVideo');
			var scrollPercentage = window.scrollY / (document.body.scrollHeight - window.innerHeight);
			var invertPercentage = Math.min(100, scrollPercentage * 200); // Increase 200 to make the inversion happen faster
			video.style.filter = `invert(${invertPercentage}%)`;
		});

		// Function to open the popup
		function openPopup() {
			document.getElementById("popup").style.display = "block";
		}

		// Function to close the popup
		function closePopup() {
			document.getElementById("popup").style.display = "none";
		}

		// Automatically open the popup when the page loads
		window.onload = function() {
			openPopup();
		};
    </script>


	<div class="popup" id="popup">
		<span class="close-btn" onclick="closePopup()">&times;</span>
		<h2>For a better page view</h2>
		<p>Fullscreen desktop or landscape mode on phone (then refresh)</p>
	</div>

	<h1 class="heading">
		<span>S</span>imulated-<span>E</span>nvironment <span>A</span>griculture <span>L</span>ab
	</h1>

	<div class="canvas-container">
		<canvas id="fluidCanvas"></canvas>
	</div>


	<div class="arrow-container" onclick="scrollToHalfPage()">
        <div class="arrow"></div>
        <div class="more-text">SCROLL DOWN FOR MORE</div>
		<a href="https://www.abe.iastate.edu/" target="_blank">
			<img src="images/Iowa_State_Cyclones_logo.svg.png" class="logo" alt="Logo">
		</a>
    </div>

	<h1 class="heading-space">
		<span>S</span>imulated-<span>E</span>nvironment <span>A</span>griculture <span>L</span>ab
	</h1>
	
	<div class="content-window">
		<div class="content1">
			<div class="hello-world">
				<div class="text-content">
					<p>hello world,\n<br><br>this is an	experimental,concept website for my work and lab\n<br><br>
						my name is <a href="https://www.linkedin.com/in/hanwook-chung-016564248/" target="linkedin" class="white-link">hanwook "han" chung</a>. 
						i am an assistant professor 
						in abe department at iowa state university (since 2024). i received my phd at the 
						university of wisconsin-madison from bse department (graduated in 2023) under the 
						guidance of dr. christopher choi. my research interests revolve around managing 
						the environment for indoor animal and plant production. controlling, optimizing, and designing 
						agricultural indoor environmental systems to be more resilient and economical through simulation is the 
						theme of my studies. some essential tools that i work with are computational 
						fluid dynamics (cfd), internet of things (iot), and data science (ml) </p>
				</div>
				<div class="video-content">
					<video width=100% height=100% playsinline autoplay muted loop id="myVideo" onscroll="changeInvertColor()">
						<source src="videos/cow_mesh_cropped.mp4" type="video/mp4">
						cow cow cow
					</video>
				</div>
			</div>
			<div class="recruitment">
				<div class="prospect-student">
					<p>(updated sping 2025) for prospective students:\n<br><br>
						<b style='color:red;'>no open graduate position at the moment! please check back the next academic semester:\n</b> <br><br>
						if you are interested in working with me on advancing/solving agricultural 
						indoor-environment systems/problems and believe you have strong background and passion for research, 
						please send me an email (hwchung at iastate dot edu) with a title "[grad school app] first and last name" to be considered. 
						your email should include following items:\n</p>
					<li>academic cv</li>
					<li>summary list of courses taken</li>
					<li>answer to - why do you want to pursue graduate school?</li>
					<li>answer to - how do you think isu and I can help achieve your goal?</li>
					<p>*i get many emails and linkedin notifications so follow the steps for consideration</p>
				</div>
			</div>
		</div>
	</div>
	<!-- <div class="footer-container">
		<div class="footer">
			&copy; <script>document.write(new Date().getFullYear())</script> HANWOOKCHUNG
		</div>
		
	</div> -->

<h1 class="heading-space">
		<span>S</span>imulated-<span>E</span>nvironment <span>A</span>griculture <span>L</span>ab
	</h1>
	
	<div class="content-window-slot">
		<div class="content1">

	
				<div class="slot-machine-wrapper">
					<div class="slot-machine1">
						<div class="words1">
							<div class="word">ADVANCING</div>
							<div class="word">EFFICIENT</div>
							<div class="word">SUSTAINABLE</div>
							<div class="word">ETHICAL</div>
							<div class="word">RESILIENT</div>
							<div class="word">LIVESTOCK</div>
							<div class="word">ACCESSIBLE</div>
							<div class="word">친환경</div>
							<div class="word">ENVIRONMENTAL</div>
							<div class="word">INTELLIGENT</div>
							<div class="word">CONSERVATIVE</div>
							<div class="word">EFFECTIVE</div>
							<div class="word">지속가능한</div>
							<div class="word">FUTURE</div>
							<div class="word">INNOVATIVE</div>
							<div class="word">REGENERATIVE</div>
							<div class="word">SCALABLE</div>
							<div class="word">GLOBAL</div>
							<div class="word">SMART</div>
							<div class="word">CIRCULAR</div>
						</div>
					</div>
					<div class="slot-machine2">
						<div class="words2">
							<div class="word">농업</div>
							<div class="word">AGRICULTURE</div>
							<div class="word">农业</div>
							<div class="word">FOOD PRODUCTION</div>
							<div class="word">LANDWIRTSCHAFT</div>
							<div class="word">TARIM</div>
							<div class="word">BARN</div>
							<div class="word">산업</div>
							<div class="word">FARMING</div>
							<div class="word">음식</div>
							<div class="word">HUSBANDRY</div>
							<div class="word">農業</div>
							<div class="word">AGRICULTURA</div>
							<div class="word">DAIRY</div>
						</div>
					</div>
				</div>
				<!-- <div class="static-word">AGRICULTURE</div> -->
			

		</div>
	</div>

	<div class="footer-container">
		<div class="footer">
			&copy; <script>document.write(new Date().getFullYear())</script> HANWOOKCHUNG
		</div>
		
	</div>


<script>

	var canvas = document.getElementById("fluidCanvas");
	var gl = canvas.getContext("webgl");	
	// canvas.width = window.innerWidth*0.98;
    function resizeCanvas() {
        canvas.height = window.innerHeight * 0.9;
        canvas.width = window.innerWidth;
    }
	resizeCanvas();
	window.addEventListener('resize', resizeCanvas);
	// canvas.height = window.innerHeight;

	canvas.focus();

	var simHeight = 2.0;	
	var cScale = canvas.height / simHeight;
	var simWidth = canvas.width / cScale;

	var U_FIELD = 0;
	var V_FIELD = 1;
	
	var FLUID_CELL = 0;
	var AIR_CELL = 1;
	var SOLID_CELL = 2;

	var cnt = 0;

	function clamp(x, min, max) 
	{
		if (x < min)
			return min;
		else if (x > max)
			return max;
		else 
			return x;
	}
	function signedDistanceToRectangle(x, y, rectX, rectY, rectWidth, rectHeight) {
		var dx = Math.abs(x - rectX) - rectWidth / 2;
		var dy = Math.abs(y - rectY) - rectHeight / 2;

		var outsideDistance = Math.sqrt(Math.max(dx, 0) ** 2 + Math.max(dy, 0) ** 2);
		var insideDistance = Math.min(Math.max(dx, dy), 0);

		return outsideDistance + insideDistance;
	}
	function signedDistanceToTiltedRectangle(x, y, rectX, rectY, rectWidth, rectHeight, angle) {
		// Convert angle from degrees to radians
		var angleRad = angle * Math.PI / 180;

		// Translate the point to the origin
		var dx = x - rectX;
		var dy = y - rectY;

		// Rotate the point in the opposite direction of the rectangle's rotation
		var rotatedX = dx * Math.cos(-angleRad) - dy * Math.sin(-angleRad);
		var rotatedY = dx * Math.sin(-angleRad) + dy * Math.cos(-angleRad);

		// Calculate the signed distance for the axis-aligned rectangle
		var distX = Math.abs(rotatedX) - rectWidth / 2;
		var distY = Math.abs(rotatedY) - rectHeight / 2;

		var outsideDistance = Math.sqrt(Math.max(distX, 0) ** 2 + Math.max(distY, 0) ** 2);
		var insideDistance = Math.min(Math.max(distX, distY), 0);

		return outsideDistance + insideDistance;
	}

	// ----------------- start of simulator ------------------------------

	class FlipFluid {
		constructor(density, width, height, spacing, particleRadius, maxParticles) {
			// fluid
			this.density = density;
			this.fNumX = Math.floor(width / spacing) + 1;
			this.fNumY = Math.floor(height / spacing) + 1;
			this.h = Math.max(width / this.fNumX, height / this.fNumY);
			this.fInvSpacing = 1.0 / this.h;
			this.fNumCells = this.fNumX * this.fNumY;

			this.u = new Float32Array(this.fNumCells);
			this.v = new Float32Array(this.fNumCells);
			this.du = new Float32Array(this.fNumCells);
			this.dv = new Float32Array(this.fNumCells);
			this.prevU = new Float32Array(this.fNumCells);
			this.prevV = new Float32Array(this.fNumCells);
			this.p = new Float32Array(this.fNumCells);
			this.s = new Float32Array(this.fNumCells);
			this.cellType = new Int32Array(this.fNumCells);
			this.cellColor = new Float32Array(3 * this.fNumCells);
			// particles
			this.maxParticles = maxParticles;
			this.particlePos = new Float32Array(2 * this.maxParticles);
			this.particleColor = new Float32Array(3 * this.maxParticles);

			for (var i = 0; i < this.maxParticles; i++)
				this.particleColor[3 * i + 2] = 0.0;

			this.particleVel = new Float32Array(2 * this.maxParticles);
			this.particleDensity = new Float32Array(this.fNumCells);
			this.particleRestDensity = 0.0;
			this.particleRadius = particleRadius;
			this.pInvSpacing = 1.0 / (2.2 * particleRadius);
			this.pNumX = Math.floor(width * this.pInvSpacing) + 1;
			this.pNumY = Math.floor(height * this.pInvSpacing) + 1;
			this.pNumCells = this.pNumX * this.pNumY;
			this.numCellParticles = new Int32Array(this.pNumCells);
			this.firstCellParticle = new Int32Array(this.pNumCells + 1);
			this.cellParticleIds = new Int32Array(maxParticles);
			this.numParticles = 0;
		}

		integrateParticles(dt, gravity) 
		{
			for (var i = 0; i < this.numParticles; i++) {
				this.particleVel[2 * i] += dt * (-gravity * 0);
				this.particlePos[2 * i] += this.particleVel[2 * i] * dt;
				this.particlePos[2 * i + 1] += this.particleVel[2 * i + 1] * dt;
			}
		}

		pushParticlesApart(numIters) 
		{
			var colorDiffusionCoeff = 0.001;
			// count particles per cell
			this.numCellParticles.fill(0);

			for (var i = 0; i < this.numParticles; i++) {
				var x = this.particlePos[2 * i];
				var y = this.particlePos[2 * i + 1];
				var xi = clamp(Math.floor(x * this.pInvSpacing), 0, this.pNumX - 1);
				var yi = clamp(Math.floor(y * this.pInvSpacing), 0, this.pNumY - 1);
				var cellNr = xi * this.pNumY + yi;
				this.numCellParticles[cellNr]++;
			}

			// partial sums
			var first = 0;

			for (var i = 0; i < this.pNumCells; i++) {
				first += this.numCellParticles[i];
				this.firstCellParticle[i] = first;
			}

			this.firstCellParticle[this.pNumCells] = first;		// guard

			// fill particles into cells
			for (var i = 0; i < this.numParticles; i++) {
				var x = this.particlePos[2 * i];
				var y = this.particlePos[2 * i + 1];
				var xi = clamp(Math.floor(x * this.pInvSpacing), 0, this.pNumX - 1);
				var yi = clamp(Math.floor(y * this.pInvSpacing), 0, this.pNumY - 1);
				var cellNr = xi * this.pNumY + yi;
				this.firstCellParticle[cellNr]--;
				this.cellParticleIds[this.firstCellParticle[cellNr]] = i;
			}

			// push particles apart
			var minDist = 2.5 * this.particleRadius;
			var minDist2 = minDist * minDist;
			for (var iter = 0; iter < numIters; iter++) {
				for (var i = 0; i < this.numParticles; i++) {
					var px = this.particlePos[2 * i];
					var py = this.particlePos[2 * i + 1];
					var pxi = Math.floor(px * this.pInvSpacing);
					var pyi = Math.floor(py * this.pInvSpacing);
					var x0 = Math.max(pxi - 1, 0);
					var y0 = Math.max(pyi - 1, 0);
					var x1 = Math.min(pxi + 1, this.pNumX - 1);
					var y1 = Math.min(pyi + 1, this.pNumY - 1);
					for (var xi = x0; xi <= x1; xi++) {
						for (var yi = y0; yi <= y1; yi++) {
							var cellNr = xi * this.pNumY + yi;
							var first = this.firstCellParticle[cellNr];
							var last = this.firstCellParticle[cellNr + 1];
							for (var j = first; j < last; j++) {
								var id = this.cellParticleIds[j];
								if (id == i)
									continue;
								var qx = this.particlePos[2 * id];
								var qy = this.particlePos[2 * id + 1];
								var dx = qx - px;
								var dy = qy - py;
								var d2 = dx * dx + dy * dy;
								if (d2 > minDist2 || d2 == 0.0) 
									continue;
								var d = Math.sqrt(d2);
								var s = 0.5 * (minDist - d) / d;
								dx *= s;
								dy *= s;
								this.particlePos[2 * i] -= dx;
								this.particlePos[2 * i + 1] -= dy;
								this.particlePos[2 * id] += dx;
								this.particlePos[2 * id + 1] += dy;
							}
						}
					}
				}
			}
		}

		handleParticleCollisions() {
			var h = 1.0 / this.fInvSpacing;
			var r = this.particleRadius;
			var minX = h + r;
			var maxX = (this.fNumX - 1) * h - r;
			var minY = h + r;
			var maxY = (this.fNumY - 1) * h - r;

			for (var i = 0; i < this.numParticles; i++) {
				var x = this.particlePos[2 * i];
				var y = this.particlePos[2 * i + 1];

				// sdf
				if (signedDistanceToRectangle(x, y, 0.6, .05, .01, 0.1) < .01) {
					this.particleVel[2 * i] = 0;
					this.particleVel[2 * i + 1] = 0;
				}
				if (signedDistanceToRectangle(x, y, 0.6, .35, .01, 0.1) < .01) {
					this.particleVel[2 * i] = 0;
					this.particleVel[2 * i + 1] = 0;
				}
				if (signedDistanceToRectangle(x, y, 1.45, .05, .01, 0.1) < .01) {
					this.particleVel[2 * i] = 0;
					this.particleVel[2 * i + 1] = 0;
				}
				if (signedDistanceToRectangle(x, y, 1.45, .35, .01, 0.1) < .01) {
					this.particleVel[2 * i] = 0;
					this.particleVel[2 * i + 1] = 0;
				}
				if (signedDistanceToTiltedRectangle(x, y, 0.75, .5, .01, 0.5, -(90-18.4)) < .01) {
					this.particleVel[2 * i] = 0;
					this.particleVel[2 * i + 1] = 0;
				}
				if (signedDistanceToTiltedRectangle(x, y, 1.3, .5, .01, 0.5, (90-18.4)) < .01) {
					this.particleVel[2 * i] = 0;
					this.particleVel[2 * i + 1] = 0;
				}
				// seudo-bouyancy
				if (x < 1.45-0.0 && x > 0.6+0.0 && y < minY+0.5) {
					this.particleVel[2 * i + 1] += 0.0025;
				} 
				// wall collisions
				if (x < minX) {
					x = minX;
					this.particleVel[2 * i] = 2;
				}
				if (x > maxX-0.02) {
					x = minX;
					y = minY + Math.random() * (maxY - minY);
				}
				if (x > 1.45 && y < minY) {
					y = minY;
					this.particleVel[2 * i + 1] = 0;
					this.particleVel[2 * i] *= 0.1;
				}
				if (x < 0.6 && y < minY) {
					y = minY;
					this.particleVel[2 * i + 1] = 0;
					this.particleVel[2 * i] *= 0.1;
				}
				if (y > maxY) {
					y = minY + Math.random() * (maxY/2 - minY);
					x = minX;
				}
				this.particlePos[2 * i] = x;
				this.particlePos[2 * i + 1] = y;
			}
		}

		updateParticleDensity()
		{
			var n = this.fNumY;
			var h = this.h;
			var h1 = this.fInvSpacing;
			var h2 = 0.5 * h;
			var d = f.particleDensity;
			d.fill(0.0);
			for (var i = 0; i < this.numParticles; i++) {
				var x = this.particlePos[2 * i];
				var y = this.particlePos[2 * i + 1];
				x = clamp(x, h, (this.fNumX - 1) * h);
				y = clamp(y, h, (this.fNumY - 1) * h);
				var x0 = Math.floor((x - h2) * h1);
				var tx = ((x - h2) - x0 * h) * h1;
				var x1 = Math.min(x0 + 1, this.fNumX-2);
				var y0 = Math.floor((y-h2)*h1);
				var ty = ((y - h2) - y0*h) * h1;
				var y1 = Math.min(y0 + 1, this.fNumY-2);
				var sx = 1.0 - tx;
				var sy = 1.0 - ty;
				if (x0 < this.fNumX && y0 < this.fNumY) d[x0 * n + y0] += sx * sy;
				if (x1 < this.fNumX && y0 < this.fNumY) d[x1 * n + y0] += tx * sy;
				if (x1 < this.fNumX && y1 < this.fNumY) d[x1 * n + y1] += tx * ty;
				if (x0 < this.fNumX && y1 < this.fNumY) d[x0 * n + y1] += sx * ty;
			}
			if (this.particleRestDensity == 0.0) {
				var sum = 0.0;
				var numFluidCells = 0;
				for (var i = 0; i < this.fNumCells; i++) {
					if (this.cellType[i] == FLUID_CELL) {
						sum += d[i];
						numFluidCells++;
					}
				}
				if (numFluidCells > 0)
					this.particleRestDensity = sum / numFluidCells;
			}
		}

		transferVelocities(toGrid, flipRatio)
		{
			var n = this.fNumY;
			var h = this.h;
			var h1 = this.fInvSpacing;
			var h2 = 0.5 * h;
			if (toGrid) {
				this.prevU.set(this.u);
				this.prevV.set(this.v);
				this.du.fill(0.0);
				this.dv.fill(0.0);
				this.u.fill(0.0);
				this.v.fill(0.0);
				for (var i = 0; i < this.fNumCells; i++) 
					this.cellType[i] = this.s[i] == 0.0 ? SOLID_CELL : AIR_CELL;
				for (var i = 0; i < this.numParticles; i++) {
					var x = this.particlePos[2 * i];
					var y = this.particlePos[2 * i + 1];
					var xi = clamp(Math.floor(x * h1), 0, this.fNumX - 1);
					var yi = clamp(Math.floor(y * h1), 0, this.fNumY - 1);
					var cellNr = xi * n + yi;
					if (this.cellType[cellNr] == AIR_CELL)
						this.cellType[cellNr] = FLUID_CELL;
				}
			}
			for (var component = 0; component < 2; component++) {
				var dx = component == 0 ? 0.0 : h2;
				var dy = component == 0 ? h2 : 0.0;
				var f = component == 0 ? this.u : this.v;
				var prevF = component == 0 ? this.prevU : this.prevV;
				var d = component == 0 ? this.du : this.dv;
				for (var i = 0; i < this.numParticles; i++) {
					var x = this.particlePos[2 * i];
					var y = this.particlePos[2 * i + 1];
					x = clamp(x, h, (this.fNumX - 1) * h);
					y = clamp(y, h, (this.fNumY - 1) * h);
					var x0 = Math.min(Math.floor((x - dx) * h1), this.fNumX - 2);
					var tx = ((x - dx) - x0 * h) * h1;
					var x1 = Math.min(x0 + 1, this.fNumX-2);
					var y0 = Math.min(Math.floor((y-dy)*h1), this.fNumY-2);
					var ty = ((y - dy) - y0*h) * h1;
					var y1 = Math.min(y0 + 1, this.fNumY-2);
					var sx = 1.0 - tx;
					var sy = 1.0 - ty;
					var d0 = sx*sy;
					var d1 = tx*sy;
					var d2 = tx*ty;
					var d3 = sx*ty;
					var nr0 = x0*n + y0;
					var nr1 = x1*n + y0;
					var nr2 = x1*n + y1;
					var nr3 = x0*n + y1;
					if (toGrid) {
						var pv = this.particleVel[2 * i + component];
						f[nr0] += pv * d0;  d[nr0] += d0;
						f[nr1] += pv * d1;  d[nr1] += d1;
						f[nr2] += pv * d2;  d[nr2] += d2;
						f[nr3] += pv * d3;  d[nr3] += d3;
					}
					else {
						var offset = component == 0 ? n : 1;
						var valid0 = this.cellType[nr0] != AIR_CELL || this.cellType[nr0 - offset] != AIR_CELL ? 1.0 : 0.0;
						var valid1 = this.cellType[nr1] != AIR_CELL || this.cellType[nr1 - offset] != AIR_CELL ? 1.0 : 0.0;
						var valid2 = this.cellType[nr2] != AIR_CELL || this.cellType[nr2 - offset] != AIR_CELL ? 1.0 : 0.0;
						var valid3 = this.cellType[nr3] != AIR_CELL || this.cellType[nr3 - offset] != AIR_CELL ? 1.0 : 0.0;

						var v = this.particleVel[2 * i + component];
						var d = valid0 * d0 + valid1 * d1 + valid2 * d2 + valid3 * d3;

						if (d > 0.0) {

							var picV = (valid0 * d0 * f[nr0] + valid1 * d1 * f[nr1] + valid2 * d2 * f[nr2] + valid3 * d3 * f[nr3]) / d;
							var corr = (valid0 * d0 * (f[nr0] - prevF[nr0]) + valid1 * d1 * (f[nr1] - prevF[nr1])
								+ valid2 * d2 * (f[nr2] - prevF[nr2]) + valid3 * d3 * (f[nr3] - prevF[nr3])) / d;
							var flipV = v + corr;

							this.particleVel[2 * i + component] = (1.0 - flipRatio) * picV + flipRatio * flipV;
						}
					}
				}
				if (toGrid) {
					for (var i = 0; i < f.length; i++) {
						if (d[i] > 0.0)
							f[i] /= d[i];
					}
					// restore solid cells
					for (var i = 0; i < this.fNumX; i++) {
						for (var j = 0; j < this.fNumY; j++) {
							var solid = this.cellType[i * n + j] == SOLID_CELL;
							if (solid || (i > 0 && this.cellType[(i - 1) * n + j] == SOLID_CELL))
								this.u[i * n + j] = this.prevU[i * n + j];
							if (solid || (j > 0 && this.cellType[i * n + j - 1] == SOLID_CELL))
								this.v[i * n + j] = this.prevV[i * n + j];
						}
					}
				}
			}
		}
		
		solveIncompressibility(numIters, dt, overRelaxation, compensateDrift = true) {
			this.p.fill(0.0);
			this.prevU.set(this.u);
			this.prevV.set(this.v);
			var n = this.fNumY;
			var cp = this.density * this.h / dt;
			for (var i = 0; i < this.fNumCells; i++) {
				var u = this.u[i];
				var v = this.v[i];
			}
			for (var iter = 0; iter < numIters; iter++) {
				for (var i = 1; i < this.fNumX-1; i++) {
					for (var j = 1; j < this.fNumY-1; j++) {
						if (this.cellType[i*n + j] != FLUID_CELL)
							continue;
						var center = i * n + j;
						var left = (i - 1) * n + j;
						var right = (i + 1) * n + j;
						var bottom = i * n + j - 1;
						var top = i * n + j + 1;
						var s = this.s[center];
						var sx0 = this.s[left];
						var sx1 = this.s[right];
						var sy0 = this.s[bottom];
						var sy1 = this.s[top];
						var s = sx0 + sx1 + sy0 + sy1;
						if (s == 0.0)
							continue;
						var div = this.u[right] - this.u[center] + 
							this.v[top] - this.v[center];
						if (this.particleRestDensity > 0.0 && compensateDrift) {
							var k = 1.0;
							var compression = this.particleDensity[i*n + j] - this.particleRestDensity;
							if (compression > 0.0)
								div = div - k * compression;
						}
						var p = -div / s;
						p *= overRelaxation;
						this.p[center] += cp * p;
						this.u[center] -= sx0 * p;
						this.u[right] += sx1 * p;
						this.v[center] -= sy0 * p;
						this.v[top] += sy1 * p;
					}
				}
			}
		}

		setSciColor(cellNr, val, minVal, maxVal) {
			val = Math.min(Math.max(val, minVal), maxVal- 0.0001);
			var d = maxVal - minVal;
			val = d == 0.0 ? 0.5 : (val - minVal) / d;
			var m = 0.25;
			var num = Math.floor(val / m);
			var s = (val - num * m) / m;
			var r, g, b;
			switch (num) {
				case 0 : r = 0.0; g = s; b = 1.0; break;
				case 1 : r = 0.0; g = 1.0; b = 1.0-s; break;
				case 2 : r = s; g = 1.0; b = 0.0; break;
				case 3 : r = 1.0; g = 1.0 - s; b = 0.0; break;
			}
			this.cellColor[3 * cellNr] = r;
			this.cellColor[3 * cellNr + 1] = g;
			this.cellColor[3 * cellNr + 2] = b;
		}

		updateCellColors() {
			this.cellColor.fill(0.0);
			for (var i = 0; i < this.fNumCells; i++) {
				if (this.cellType[i] == SOLID_CELL) {
					this.cellColor[3*i] = 0.5;
					this.cellColor[3*i + 1] = 0.5;
					this.cellColor[3*i + 2] = 0.5;
				}
				else if (this.cellType[i] == FLUID_CELL) {
					var d = this.particleDensity[i];
					if (this.particleRestDensity > 0.0)
						d /= this.particleRestDensity;
					this.setSciColor(i, d, 0.0, 2.0);
				}
			}
		}

		simulate(dt, gravity, flipRatio, numPressureIters, numParticleIters, overRelaxation, compensateDrift, separateParticles) 
		{
			var numSubSteps = 1;
			var sdt = dt / numSubSteps;
			for (var step = 0; step < numSubSteps; step++) {
				this.integrateParticles(sdt, gravity);
				if (separateParticles)
					this.pushParticlesApart(numParticleIters); 
				this.handleParticleCollisions()
				this.transferVelocities(true);
				this.updateParticleDensity();
				this.solveIncompressibility(numPressureIters, sdt, overRelaxation, compensateDrift);
				this.transferVelocities(false, flipRatio);
			}
			this.updateCellColors();
		}
	}

	// ----------------- end of simulator ------------------------------

	var scene = 
	{
		gravity : -9.81,
		dt : 1.0 / 120.0,
		flipRatio : 0.9,
		numPressureIters : 100,
		numParticleIters : 2,
		frameNr : 0,
		overRelaxation : 1.9,
		compensateDrift : true,
		separateParticles : true,
		paused: false,
		showObstacle: true,
		showParticles: true,
		fluid: null
	};

	function setupScene() 
	{
		scene.obstacleRadius = 0.2;
		scene.overRelaxation = 1.9;
		scene.dt = 1.0 / 60.0;
		scene.numPressureIters = 50;
		scene.numParticleIters = 2;
		var res = 100;
		var tunnelHeight = 1.0 * simHeight;
		var tunnelWidth = 1.0 * simWidth;
		var h = tunnelHeight / res;
		var density = 1000.0;
		var relAirHeight = 0.8
		var relAirWidth = 0.6
		// dam break
		// compute number of particles
		var r = 0.3 * h;	// particle radius w.r.t. cell size
		var dx = 2.0 * r;
		var dy = Math.sqrt(3.0) / 2.0 * dx;

 		var numX = Math.floor((relAirWidth * tunnelWidth - 2.0 * h - 2.0 * r) / dx)/2;
		var numY = Math.floor((relAirHeight * tunnelHeight - 2.0 * h - 2.0 * r) / dy)/2;
		var maxParticles = numX * numY;		

		f = scene.fluid = new FlipFluid(density, tunnelWidth, tunnelHeight, h, r, maxParticles);

		f.numParticles = numX * numY;
		var p = 0;
		for (var i = 0; i < numX; i++) {
			for (var j = 0; j < numY; j++) {
				f.particlePos[p++] = h + r + dx * i + (j % 2 == 0 ? 0.0 : r);
				f.particlePos[p++] = h + r + dy * j
			}
		}

		var n = f.fNumY;
		for (var i = 0; i < f.fNumX; i++) {
			for (var j = 0; j < f.fNumY; j++) {
				var s = 1.0;
				if (i == 0 || i == f.fNumX-1 || j == 0)
					s = 0.0;
				f.s[i*n + j] = s
			}
		}
	}
	// draw -------------------------------------------------------
	const pointVertexShader = `
		attribute vec2 attrPosition;
		attribute vec3 attrColor;
		uniform vec2 domainSize;
		uniform float pointSize;
		uniform float drawDisk;

		varying vec3 fragColor;
		varying float fragDrawDisk;

		void main() {
		vec4 screenTransform = 
			vec4(2.0 / domainSize.x, 2.0 / domainSize.y, -1.0, -1.0);
		gl_Position =
			vec4(attrPosition * screenTransform.xy + screenTransform.zw, 0.0, 1.0);

		gl_PointSize = pointSize;
		fragColor = attrColor;
		fragDrawDisk = drawDisk;
		}
	`;
	const pointFragmentShader = `
		precision mediump float;
		varying vec3 fragColor;
		varying float fragDrawDisk;

		void main() {
			if (fragDrawDisk == 1.0) {
				float rx = 0.5 - gl_PointCoord.x;
				float ry = 0.5 - gl_PointCoord.y;
				float r2 = rx * rx + ry * ry;
				if (r2 > 0.25)
					discard;
			}
			gl_FragColor = vec4(fragColor, 1.0);
		}
	`;
	const meshVertexShader = `
		attribute vec2 attrPosition;
		uniform vec2 domainSize;
		uniform vec3 color;
		uniform vec2 translation;
		uniform float scale;

		varying vec3 fragColor;

		void main() {
			vec2 v = translation + attrPosition * scale;
		vec4 screenTransform = 
			vec4(2.0 / domainSize.x, 2.0 / domainSize.y, -1.0, -1.0);
		gl_Position =
			vec4(v * screenTransform.xy + screenTransform.zw, 0.0, 1.0);

		fragColor = color;
		}
	`;
	const meshFragmentShader = `
		precision mediump float;
		varying vec3 fragColor;

		void main() {
			gl_FragColor = vec4(fragColor, 1.0);
		}
	`;

	function createShader(gl, vsSource, fsSource) 
	{
		const vsShader = gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(vsShader, vsSource);
		gl.compileShader(vsShader);
		if (!gl.getShaderParameter(vsShader, gl.COMPILE_STATUS))
			console.log("vertex shader compile error: " + gl.getShaderInfoLog(vsShader));
		const fsShader = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(fsShader, fsSource);
		gl.compileShader(fsShader);
		if (!gl.getShaderParameter(fsShader, gl.COMPILE_STATUS))
			console.log("fragment shader compile error: " + gl.getShaderInfoLog(fsShader));
		var shader = gl.createProgram();
		gl.attachShader(shader, vsShader);
		gl.attachShader(shader, fsShader);
		gl.linkProgram(shader);
		return shader;
	}

	var pointShader = null;
	var meshShader = null;
	var pointVertexBuffer = null;
	var pointColorBuffer = null;
	var diskVertBuffer = null;
	var diskIdBuffer = null;

	function draw() {
		gl.clearColor(0.0, 0.0, 0.0, 0.0);
		gl.clear(gl.COLOR_BUFFER_BIT);
		gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
		
		// prepare shaders
		if (pointShader == null)
			pointShader = createShader(gl, pointVertexShader, pointFragmentShader);
		
		if (meshShader == null)
			meshShader = createShader(gl, meshVertexShader, meshFragmentShader);

		// air
		if (scene.showParticles) {
			gl.clear(gl.DEPTH_BUFFER_BIT);
			var pointSize = 2.0 * scene.fluid.particleRadius / simWidth * canvas.width;
			gl.useProgram(pointShader);
			gl.uniform2f(gl.getUniformLocation(pointShader, 'domainSize'), simWidth, simHeight);
			gl.uniform1f(gl.getUniformLocation(pointShader, 'pointSize'), pointSize);
			gl.uniform1f(gl.getUniformLocation(pointShader, 'drawDisk'), 1.0);

			if (pointVertexBuffer == null)
				pointVertexBuffer = gl.createBuffer();

			if (pointColorBuffer == null)
				pointColorBuffer = gl.createBuffer();

			gl.bindBuffer(gl.ARRAY_BUFFER, pointVertexBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, scene.fluid.particlePos, gl.DYNAMIC_DRAW);
			var posLoc = gl.getAttribLocation(pointShader, 'attrPosition');
			gl.enableVertexAttribArray(posLoc);
			gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
			gl.bindBuffer(gl.ARRAY_BUFFER, pointColorBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, scene.fluid.particleColor, gl.DYNAMIC_DRAW);
			var colorLoc = gl.getAttribLocation(pointShader, 'attrColor');
			gl.enableVertexAttribArray(colorLoc);
			gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);
			gl.drawArrays(gl.POINTS, 0, scene.fluid.numParticles); 
			gl.disableVertexAttribArray(posLoc);
			gl.disableVertexAttribArray(colorLoc);
			gl.bindBuffer(gl.ARRAY_BUFFER, null);
		}

		gl.useProgram(meshShader);
		gl.uniform1f(gl.getUniformLocation(meshShader, 'scale'), scene.obstacleRadius + scene.fluid.particleRadius);
		
		// NV barn
		var arrayOfArrays = [[0.6, 0.05, 0.1, 0.5, 0],[1.45, 0.05, 0.1, 0.5, 0],[0.6, 0.35, 0.1, 0.5, 0],
		[1.45, 0.35, 0.1, 0.5, 0],[0.75, .5, .1, 2.5, -(90-18.4)],[1.3, .5, .1, 2.5, (90-18.4)]];

		for (var array of arrayOfArrays) {
			var rectVertBuffer = gl.createBuffer();
			var rectWidth = array[2];
			var rectHeight = array[3];
			var angle = array[4];

			var radians = angle * Math.PI / 180;

			var rectVerts = new Float32Array([
				Math.cos(radians) * (-rectWidth / 2) - Math.sin(radians) * (-rectHeight / 2),
				Math.sin(radians) * (-rectWidth / 2) + Math.cos(radians) * (-rectHeight / 2),
				Math.cos(radians) * (rectWidth / 2) - Math.sin(radians) * (-rectHeight / 2),
				Math.sin(radians) * (rectWidth / 2) + Math.cos(radians) * (-rectHeight / 2),
				Math.cos(radians) * (rectWidth / 2) - Math.sin(radians) * (rectHeight / 2),
				Math.sin(radians) * (rectWidth / 2) + Math.cos(radians) * (rectHeight / 2),
				Math.cos(radians) * (-rectWidth / 2) - Math.sin(radians) * (rectHeight / 2),
				Math.sin(radians) * (-rectWidth / 2) + Math.cos(radians) * (rectHeight / 2)
			]);

			gl.bindBuffer(gl.ARRAY_BUFFER, rectVertBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, rectVerts, gl.DYNAMIC_DRAW);

			var rectIdBuffer = gl.createBuffer();
			var rectIds = new Uint16Array([
				0, 1, 2,
				0, 2, 3 
			]);

			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, rectIdBuffer);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, rectIds, gl.DYNAMIC_DRAW);

			gl.clear(gl.DEPTH_BUFFER_BIT);
			gl.useProgram(meshShader);
			gl.uniform2f(gl.getUniformLocation(meshShader, 'domainSize'), simWidth, simHeight);
			gl.uniform3f(gl.getUniformLocation(meshShader, 'color'), 0.0, 0.0, 0.0);
			gl.uniform2f(gl.getUniformLocation(meshShader, 'translation'), array[0], array[1]);
			gl.bindBuffer(gl.ARRAY_BUFFER, rectVertBuffer);
			gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
			gl.enableVertexAttribArray(posLoc);
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, rectIdBuffer);
			gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
			gl.disableVertexAttribArray(posLoc);
		}
	}

	// interaction -------------------------------------------------------
    // var mouseDown = false;

	// function startDrag(x, y) {
	// 	let bounds = canvas.getBoundingClientRect();
	// 	let mx = x - bounds.left - canvas.clientLeft;
	// 	let my = y - bounds.top - canvas.clientTop;
	// 	mouseDown = true;
	// 	x = mx / cScale;
	// 	y = (canvas.height - my) / cScale;
	// 	setObstacle(x,y, true);
	// 	scene.paused = false;
	// }

	// function drag(x, y) {
	// 	if (mouseDown) {
	// 		let bounds = canvas.getBoundingClientRect();
	// 		let mx = x - bounds.left - canvas.clientLeft;
	// 		let my = y - bounds.top - canvas.clientTop;
	// 		x = mx / cScale;
	// 		y = (canvas.height - my) / cScale;
	// 		setObstacle(x,y, false);
	// 	}
	// }

	// function endDrag() {
	// 	mouseDown = false;
	// }

	// canvas.addEventListener('mousedown', event => {
	// 	startDrag(event.x, event.y);
	// });

	// canvas.addEventListener('mouseup', event => {
	// 	endDrag();
	// });

	// canvas.addEventListener('mousemove', event => {
	// 	drag(event.x, event.y);
	// });

	// canvas.addEventListener('touchstart', event => {
	// 	startDrag(event.touches[0].clientX, event.touches[0].clientY)
	// });

	// canvas.addEventListener('touchend', event => {
	// 	endDrag()
	// });

	// canvas.addEventListener('touchmove', event => {
	// 	event.preventDefault();
	// 	event.stopImmediatePropagation();
	// 	drag(event.touches[0].clientX, event.touches[0].clientY)
	// }, { passive: true});
	
	// main -------------------------------------------------------
	function simulate()	{
		if (!scene.paused)
			scene.fluid.simulate(
				scene.dt, scene.gravity, scene.flipRatio, scene.numPressureIters, scene.numParticleIters, 
				scene.overRelaxation, scene.compensateDrift, scene.separateParticles, scene.colorFieldNr);
			scene.frameNr++;
	}

	function update() {
		simulate();
		draw();
		requestAnimationFrame(update);
	}

	setupScene();

	update();

</script> 
<script>
	const wordsContainer = document.querySelector('.words1');
	const wordElements = Array.from(wordsContainer.children);

	wordElements.forEach(word => {
		const randomColor = getRandomColor();
		word.style.color = randomColor;
	});

	function getRandomColor() {
		const red = Math.floor(Math.random() * 256);
		const green = Math.floor(Math.random() * 256);
		const blue = Math.floor(Math.random() * 256);
		return `rgb(${red}, ${green}, ${blue})`;
	}

	let currentOffset = 0;
	function rotateWords1() {
		currentOffset -= 120;
		wordsContainer.style.transition = 'transform 0.5s';
		wordsContainer.style.transform = `translateY(${currentOffset}px)`;
		setTimeout(() => {
			wordsContainer.style.transition = 'none';
			const firstWord = wordsContainer.firstElementChild;
			wordsContainer.appendChild(firstWord);
			currentOffset += 120;
			wordsContainer.style.transform = `translateY(${currentOffset}px)`;
		}, 500);
	}

	setInterval(rotateWords1, 2000);
</script>
	
<script>
	const wordsContainer2 = document.querySelector('.words2');
	const wordElements2 = Array.from(wordsContainer2.children);

	wordElements2.forEach(word => {
	const randomColor = getRandomColor();
	word.style.color = randomColor;
	});

	function getRandomColor() {
	const red = Math.floor(Math.random() * 256);
	const green = Math.floor(Math.random() * 256);
	const blue = Math.floor(Math.random() * 256);
	return `rgb(${red}, ${green}, ${blue})`;
	}

	let currentOffset2 = 0;
	function rotateWords2() {
	currentOffset2 += 120;
	wordsContainer2.style.transition = 'transform 0.5s';
	wordsContainer2.style.transform = `translateY(${currentOffset2}px)`;
	setTimeout(() => {
		wordsContainer2.style.transition = 'none';
		const lastWord = wordsContainer2.lastElementChild;
		wordsContainer2.insertBefore(lastWord, wordsContainer2.firstChild);
		currentOffset2 -= 120;
		wordsContainer2.style.transform = `translateY(${currentOffset2}px)`;
	}, 500);
	}

	setInterval(rotateWords2, 5000); // Change every 5 seconds
</script>

</body>
</html>